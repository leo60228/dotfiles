" Misc settings {{{
" vi:set sw=2:
set nocp
set history=50                  " keep 50 lines of command line history
set ruler                       " show the cursor position all the time
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.png,.jpg
set backspace=indent,eol,start  " more powerful backspacing
set tabstop=4 softtabstop=0 expandtab shiftwidth=4 smarttab ai
set relativenumber wrap shiftround
let mapleader = ","
let maplocalleader = ","
set encoding=utf-8
set statusline=%f\ (%y)
set foldlevelstart=0
set hlsearch incsearch
set t_PS=[200~
let &t_SI .= "\<Esc>[6 q"
let &t_EI .= "\<Esc>[2 q"
set undofile
set shortmess-=F
set updatetime=300
set completeopt-=preview

set termguicolors
set background=dark
colorscheme vriselenized

filetype plugin indent on
" }}}

" Restore cursor {{{
set viminfo='10,\"100,:20,%,n~/.viminfo

function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END
" }}}

" Formatting {{{

" tabs
highlight SpecialKey ctermfg=1
set list
set listchars=tab:\ \ ,trail:â—Œ
" }}}

" Mappings {{{
noremap  - ddp
noremap  _ ddkP
inoremap <c-d> <esc>"_ddi
inoremap <c-u> <esc>maviwU`aa
nnoremap <c-u> maviwU`a
nnoremap <leader>ve :vsplit $HOME/dotfiles/neovim/vimrc<cr>
nnoremap <leader>vs :source $HOME/dotfiles/neovim/vimrc<cr>
nnoremap <leader>r <Cmd>RG<cr>
nnoremap <leader>g :Git 
nnoremap <leader>G <Cmd>Git<cr>
nnoremap <C-P> <Cmd>Files<cr>
nnoremap H ^
nnoremap L $
inoremap jk <esc>
nnoremap <leader>w <c-w>
onoremap p i(
inoremap <silent><expr> <c-space> coc#refresh()
inoremap <c-space> <c-x><c-o>
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
nmap     <leader>c <C-L>
vnoremap <M-/> <Esc>/\%V
nmap     <M-/> m`vi}<Esc>``/\%V

lua <<EOF
  vim.keymap.set({ 'n' }, '<Leader>t', function()
    if next(vim.lsp.get_clients({ bufnr = vim.fn.bufnr() })) == nil then
      FzfLua.tags()
    else
      FzfLua.lsp_workspace_symbols()
    end
  end)
  vim.keymap.set({ 'n' }, '<M-[>', function()
    if next(vim.lsp.get_clients({ bufnr = vim.fn.bufnr() })) == nil then
      FzfLua.btags()
    else
      FzfLua.lsp_document_symbols()
    end
  end)

  vim.keymap.set({ 'n' }, '<Leader>s', vim.lsp.buf.hover)
  vim.keymap.set({ 'n' }, '<Leader>a', vim.lsp.buf.code_action)
EOF

function! s:EnableRelativeAutocomplete() abort
  let b:relative_autocomplete_cleanup_pending = 1
  lcd %:p:h
endfunction

function! s:DisableRelativeAutocomplete() abort
  if exists('b:relative_autocomplete_cleanup_pending') && b:relative_autocomplete_cleanup_pending
    lcd -
    let b:relative_autocomplete_cleanup_pending = 0
  endif
endfunction

inoremap <C-x><C-f> <C-o>:call <SID>EnableRelativeAutocomplete()<CR><C-x><C-f>

augroup relative_file_autocomplete
  autocmd!
  autocmd InsertLeave * call s:DisableRelativeAutocomplete()
augroup END

if has('ide')
  nmap <leader>cn <Action>(GotoNextError)
  nmap <leader>cN <Action>(GotoPreviousError)
  nmap <leader>a <Action>(ShowIntentionActions)
  nmap <leader>f <Action>(ReformatCode)
  nmap <leader>i <Action>(OptimizeImports)
else
  nnoremap <leader>cn <Cmd>cnext<cr>
  nnoremap <leader>cN <Cmd>cprevious<cr>
endif
" }}}

" Plugin settings {{{
" hardtime
let g:hardtime_allow_different_key = 1
let g:hardtime_default_on = 1
let g:list_of_disabled_keys = ["<UP>", "<DOWN>", "<LEFT>", "<RIGHT>"]

" OmniSharp
let g:OmniSharp_selector_ui = ''
let g:OmniSharp_loglevel = 'none' " workaround for log file path being in store
let g:OmniSharp_highlighting = 3

" Vimspector
let g:vimspector_base_dir = expand('$HOME/.vimspector')
let g:vimspector_enable_mappings = 'HUMAN'

" nvim-treesitter
lua <<EOF
  local has_configs, configs = pcall(require, 'nvim-treesitter.configs')
  if not has_configs then
    return
  end
  configs.setup({
    modules = {},
    ensure_installed = {},
    sync_install = false,
    auto_install = false,
    ignore_install = {},

    highlight = {
      enable = true,
      custom_captures = {
        ['comment'] = 'Comment',
        ['string.special'] = 'Special',
        ['include'] = 'Keyword',
        ['punctuation.delimiter'] = 'NONE',
        ['punctuation.bracket'] = 'NONE',
      },
      additional_vim_regex_highlighting = { 'vim', 'nix' },
    },
    playground = {
      enable = true,
    },
    refactor = {
      navigation = {
        enable = true,
      },
    },
    textobjects = {
      select = {
        enable = true,
        keymaps = {
          ['is'] = '@string.inner',
          ['as'] = { query = '@string', query_group = 'highlights' },
          ['i}'] = '@block.inner',
          ['a}'] = '@block.outer',
        },
      },
      move = {
        enable = true,
        goto_next_start = {
          ['<M-.>'] = '@statement.outer',
          ['}'] = '@block.inner',
        },
        goto_previous_start = {
          ['<M-,>'] = '@statement.outer',
          ['{'] = '@block.inner',
        },
      },
    },
  })
EOF

hi! link @variable Identifier

" vim-auto-save
let g:auto_save = 0

" nvim-echo-diagnostics
lua <<EOF
  vim.diagnostic.config({ virtual_text = false })

  require('echo-diagnostics').setup({
    show_diagnostic_number = false,
    show_diagnostic_source = false,
  })
EOF

" jupytext-nvim
lua <<EOF
  local has_jupytext, jupytext = pcall(require, 'jupytext')
  if not has_jupytext then
    return
  end
  jupytext.setup({
    format = 'auto:percent',
  })
EOF

" vim-pasta
let g:pasta_disabled_filetypes = []
let g:pasta_paste_before_mapping = ']P'
let g:pasta_paste_after_mapping = ']p'

" fzf-lua
lua <<EOF
  local has_fzf_lua, fzf_lua = pcall(require, 'fzf-lua')
  if not has_fzf_lua then
    return
  end
  fzf_lua.setup({
    'fzf-vim',
    fzf_colors = true,
    defaults = { git_icons = false, file_icons = false },
    winopts = { preview = { hidden = false } },
    btags = { ctags_autogen = false },
  })
EOF

" mini.keymap
lua <<EOF
  vim.keymap.del('i', 'jk')
  if not JK_MAPPED then
    require('mini.keymap').map_combo({ 'i', 'c', 'x', 's' }, 'jk', '<BS><BS><Esc>')
    JK_MAPPED = true
  end
EOF

" nvim-lspconfig
lua <<EOF
  vim.lsp.enable('basedpyright')
  vim.lsp.config('basedpyright', {
    settings = {
      basedpyright = {
        analysis = {
          typeCheckingMode = 'standard',
        },
      },
    },
  })

  vim.lsp.enable('ts_ls')
  vim.lsp.config('ts_ls', {
    init_options = {
      preferences = {
        includeInlayFunctionParameterTypeHints = true,
        includeInlayVariableTypeHints = true,
        includeInlayPropertyDeclarationTypeHints = true,
        includeInlayFunctionLikeReturnTypeHints = true,
      }
    }
  })

  vim.lsp.enable('rust_analyzer')
  vim.lsp.enable('eslint')
  vim.lsp.enable('nil_ls')
  vim.lsp.enable('lua_ls')

  vim.diagnostic.config({
    signs = {
      severity = { min = vim.diagnostic.severity.INFO },
    },
  })
  vim.lsp.inlay_hint.enable()

  vim.api.nvim_create_autocmd('LspAttach', {
    callback = function(args)
      local client = vim.lsp.get_client_by_id(args.data.client_id)
      if client ~= nil then
        client.server_capabilities.semanticTokensProvider = nil
      end
    end,
  })
EOF
highlight DiagnosticUnderlineHint guisp=#184956 gui=underdotted
highlight LspInlayHint guifg=#2d5b69 gui=NONE

" conform.nvim
lua <<EOF
  local has_conform, conform = pcall(require, 'conform')
  if not has_conform then
    return
  end
  conform.setup({
    formatters_by_ft = {
      python = { 'ruff_format' },
      rust = { 'rustfmt' },
      nix = { 'nixfmt' },
      lua = { 'stylua' },
      vim = { 'vim_indent', 'injected' },
    },
    default_format_opts = {
      lsp_format = 'fallback',
    },
    formatters = {
      vim_indent = {
        format = function(_, ctx, _, callback)
          local view = vim.fn.winsaveview()
          local old_start_l, old_start_c = unpack(vim.api.nvim_buf_get_mark(0, '<'))
          local old_end_l, old_end_c = unpack(vim.api.nvim_buf_get_mark(0, '>'))

          if ctx.range ~= nil then
            vim.api.nvim_buf_set_mark(0, '<', ctx.range['start'][1], ctx.range['start'][2], {})
            vim.api.nvim_buf_set_mark(0, '>', ctx.range['end'][1], ctx.range['end'][2], {})
          end

          local cmd = (ctx.range ~= nil) and 'gv=' or 'gg=G'
          vim.cmd('silent normal! ' .. cmd)
          local out_lines = vim.api.nvim_buf_get_lines(0, 0, -1, true)
          vim.cmd('silent normal! u')

          callback(nil, out_lines)

          vim.api.nvim_buf_set_mark(0, '<', old_start_l, old_start_c, {})
          vim.api.nvim_buf_set_mark(0, '>', old_end_l, old_end_c, {})
          vim.fn.winrestview(view)
        end,
      },
    },
  })

  vim.api.nvim_create_autocmd('BufEnter', {
    pattern = '*',
    callback = function(args)
      local formatters, lsp = require('conform').list_formatters_to_run(args.buf)
      if not lsp and next(formatters) ~= nil then
        vim.bo[args.buf].formatexpr = "v:lua.require'conform'.formatexpr()"
      end
    end,
  })

  vim.keymap.set({ 'n' }, '<Leader>f', conform.format)
EOF

" otter.nvim
lua <<EOF
  local has_otter, otter = pcall(require, 'otter')
  if not has_otter or otter.did_setup then
    return
  end
  otter.setup({
    lsp = {
      diagnostic_update_events = { 'BufWritePost', 'InsertLeave', 'TextChanged' },
    },
  })

  vim.api.nvim_create_autocmd('FileType', {
    pattern = 'vim',
    callback = function()
      otter.activate()
    end,
  })
EOF

" lazydev.nvim
lua <<EOF
  local has_lazydev, lazydev = pcall(require, 'lazydev')
  if not has_lazydev then
    return
  end
  lazydev.setup()
EOF

" }}}

" Filetype commands {{{
augroup vimrc
  autocmd!

  autocmd FileType rust nnoremap <buffer> <localleader>c I// <esc>
  autocmd FileType rust nnoremap <buffer> <localleader>sr ^O#[serde(rename = "")]<esc>^ci"

  autocmd FileType rust iabbrev <buffer> retu return
  autocmd FileType rust iabbrev <buffer> return <nop>

  autocmd FileType rust let b:auto_save = 1
  autocmd FileType scala let b:auto_save = 1

  autocmd BufRead,BufNewFile *.astro set filetype=astro
  autocmd BufRead,BufNewFile *.nix set filetype=nix
  autocmd BufRead,BufNewFile *.pio set filetype=pioasm

  autocmd FileType vim setlocal foldmethod=marker

  autocmd BufEnter * if &ft !=# 'yaml' | silent! unmap <buffer> {| silent! unmap <buffer> }| end

  if !has('ide')
    autocmd CursorHold * lua require('echo-diagnostics').echo_line_diagnostic()
  endif
augroup END
" }}}
